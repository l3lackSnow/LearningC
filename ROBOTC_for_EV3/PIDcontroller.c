#pragma config(Motor,  motorA,          liftmotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightmotor,    tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          leftmotor,     tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float cmtoticks(float cm)
{
	// 350 ticks per motor revolution
	// Gearing: "12:20"
	// "3:5" Gear ratio

	// 1850 ticks per track revolution
	// Motor control will read 3700 ticks

	// Tracks are 5cm radius
	// C = 31.4

	// 3700 ticks = 31.4 cm
	// 1 cm =  ticks 117.834

	float ticks;
	ticks = 117.834 * cm;
	return ticks;

}

void PIDbasecontrol1 (float dest, float time)
{
	float Kp = 0.05;
	float proportion = 0;
	float error = 0;
	float finalpower = 0;

	float Ki = 0.000025;
	float integralraw = 0;
	float integral = 0;

	bool rtime = true;

	nMotorEncoder[leftmotor] = 0;
	nMotorEncoder[rightmotor] = 0;

	while(time1[T1] < time)
	{
		error = cmtoticks(dest) - ((-1)*nMotorEncoder[leftmotor] + (-1)*nMotorEncoder[rightmotor]);

		proportion = (Kp*error);

		integralraw = integralraw + error;
		integral = Ki * integralraw;

		finalpower = proportion + integral; // Ideally, Proportion + Integral + Derivative

		motor[leftmotor] = finalpower;
		motor[rightmotor] = finalpower;

		if(rtime)
		{
			clearTimer(T1);
		}

		if(error < 40)
		{
			rtime = false;
		}
		wait1Msec(40);
	}
	wait1Msec(1000);
}

void PIDliftcontrol (float dest, float time)
{
	float Kp;
	if(dest < 20)
	{
		Kp = 0.08;
	}
	else
	{
		Kp = 0.3;
	}
	float proportion;
	float error;
	float finalpower;

	float Ki;
	if(dest < 20)
	{
		Ki = 0.01;
	}
	else
	{
		Ki = 0.5;
	}
	float integralraw;
	float integral;
	int integralactivezone = 30;

	bool rtime = true;

	//	nMotorEncoder[liftmotor] = 0;
	clearTimer(T2);

	while(time1[T2] < time)
	{
		error = dest - nMotorEncoder[liftmotor];

		proportion = (Kp*error);

		finalpower = proportion; // Ideally, Proportion + Integral + Derivative

		motor[liftmotor] = finalpower;

		if(rtime)
		{
			clearTimer(T2);
		}

		if(error < 10)
		{
			rtime = false;
		}
		wait1Msec(40);
	}
}

task main()
{

	clearTimer(T1);

	PIDbasecontrol1(10, 1000);

	PIDliftcontrol(210, 1000); //210 ticks

	PIDliftcontrol(20, 1000);

	PIDbasecontrol1(-10, 1000);

}
