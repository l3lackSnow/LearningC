#pragma config(Motor,  motorA,          liftmotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftmotor,     tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          rightmotor,    tmotorEV3_Large, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* Since August 21th, 2018 */
// ALLEN TAO //
/* Completed by yours truly, August 24, 2018 */

// Not necessarily optimally programmed, coded with the intention of mastering PID control.

// [ * ] Note, the lift of the bot must be calibrated in a way such that the fork touches the ground by raising and dropped the lift all the way.

void sustainLift(int pos)
{
	float liftKp = 0.2;

	float lifterror;
	float liftfinalpower;

	if(pos > nMotorEncoder[liftmotor])
	{
		lifterror = pos - nMotorEncoder[liftmotor];
		liftfinalpower = lifterror * liftKp;
		motor[liftmotor] = liftfinalpower;
	}
	else if(pos < nMotorEncoder[liftmotor])
	{
		lifterror = pos - nMotorEncoder[liftmotor];
		liftfinalpower = lifterror * liftKp;
		motor[liftmotor] = liftfinalpower;
	}
}
void PIDliftcontrol (int dest, float time)
{
	bool firstRun = true;

	float Kp;
	if(dest < 30)
	{
		Kp = 0.1; // Slow drop
	}
	else
	{
		Kp = 0.3; // Fast lift
	}
	float proportion;
	float error;
	float finalpower;

	float Ki;
	if(dest < 30)
	{
		Ki = 0.008;
	}
	else
	{
		Ki = 0.02;
	}
	float integralraw;
	float integral;
	int integralactivezone = 230; // We don't really need an integral active zone we just need integral to step in for heavier loads
	int integralpowerlimit = 57/Ki;

	float Kd = 0.5;
	if(dest < 30)
	{
		Kd = -0.25;
	}
	else
	{
		Kd = 0.25;
	}
	float derivative;
	float lastError = 0; // Reset last error

	bool rtime = true;

	clearTimer(T2);

	while(time1[T2] < time)
	{
		error = dest - nMotorEncoder[liftmotor];

		proportion = (Kp*error); // Calculate proportion

		if(abs(error) <= integralactivezone && error != 0) // Calculate integral and control it
		{
			integralraw = integral + error;
			if(integralraw > integralpowerlimit)
			{
				integralraw = integralpowerlimit;
			}
			if(integralraw < -integralpowerlimit)
			{
				integralraw = -integralpowerlimit;
			}
			integral = Ki * integralraw;
		}
		if(firstRun)
		{
			derivative = 0;
			lastError = error;
		}
		else
		{
			derivative = Kd * (abs(error) - abs(lastError)); // Caluclate derivate(negative value)
			lastError = error; // Sets error of this loop so that the next loop it becomes the outdated error
		}
		if(error == 0)
		{
			derivative = 0;
		}

		finalpower = proportion + integral + derivative; // Ideally, Proportion + Integral + Derivative

		motor[liftmotor] = finalpower;

		if(rtime)
		{
			clearTimer(T2);
		}

		if(abs(error) < 50)
		{
			rtime = false;
		}

		firstRun = false;

		wait1Msec(40);
	}
}

task main()
{
	nMotorEncoder[liftmotor] = 0;
	nMotorEncoder[leftmotor] = 0;
	nMotorEncoder[rightmotor] = 0;

	int motorPos = nMotorEncoder[liftmotor];


	while(true)
	{

		if(getIRRemoteButtons(S4) == 1)
		{
			motor[leftmotor] = 127;
		}
		else if(getIRRemoteButtons(S4) == 2)
		{
			motor[leftmotor] = -127;
		}
		else if(getIRRemoteButtons(S4) == 3)
		{
			motor[rightmotor] = 127;
		}
		else if(getIRRemoteButtons(S4) == 4)
		{
			motor[rightmotor] = -127;
		}
		else if(getIRRemoteButtons(S4) == 5)
		{
			motor[leftmotor] = 127;
			motor[rightmotor] = 127;
		}
		else if(getIRRemoteButtons(S4) == 6)
		{
			motor[leftmotor] = 127;
			motor[rightmotor] = -127;
		}
		else if(getIRRemoteButtons(S4) == 7)
		{
			motor[leftmotor] = -127;
			motor[rightmotor] = 127;
		}
		else if(getIRRemoteButtons(S4) == 8)
		{
			motor[leftmotor] = -127;
			motor[rightmotor] = -127;
		}
		else if(getIRRemoteButtons(S4) == 9)
		{
			PIDliftcontrol(230, 1000);
			motorPos = 230; // Set motorPos to full lift position(230)

		}
		else if(getIRRemoteButtons(S4) == 0)
		{
			motor[leftmotor] = 0;
			motor[rightmotor] = 0;

			sustainLift(motorPos);
		}
		else
		{
			PIDliftcontrol(15, 1000);
			motorPos = 15; // Set motorPos to full drop position(15)
		}
		wait1Msec(40);
	}

}
